class Huia::Parser

  token IDENTIFIER EQUAL PLUS MINUS ASTERISK FWD_SLASH COLON FLOAT INTEGER STRING EXPO INDENT OUTDENT OPAREN CPAREN DOT SIGNATURE SYMBOL NL EOF PIPE COMMA NIL TRUE FALSE EQUALITY CALL SELF CONSTANT

  prechigh
    left EXPO
    left ASTERISK FWD_SLASH PERCENT
    left PLUS MINUS

    right EQUAL
  preclow

  rule
    statements:   statement
                | statements statement             { return scope }

    statement:  expr eol                           { return scope.append val[0] }
              | expr                               { return scope.append val[0] }
              | eol                                { return scope }

    eol:        NL | EOF
    nlq:        NL |

    expr:        literal
               | variable
               | grouped_expr
               | binary_op
               | method_call
               | constant

    constant:          CONSTANT                         { return constant val[0] }

    indented:          indented_w_stmts
                     | indented_w_expr
                     | indented_wo_stmts
    indented_w_stmts:  indent statements outdent        { return val[0] }
    indented_w_expr:   indent expr outdent              { return val[0].append(val[1]) }
    indented_wo_stmts: indent outdent                   { return val[0] }
    outdent:           OUTDENT { return pop_scope }


    indent_w_args:     indent_pipe indent_args PIPE nlq INDENT { return val[0] }
    indent_pipe:       PIPE   { return push_scope }
    indent_wo_args:    INDENT { return push_scope }
    indent:            indent_w_args
                     | indent_wo_args

    indent_args:       indent_arg
                     | indent_args COMMA indent_arg
    indent_arg:        arg_var                             { return scope.add_argument val[0] }
                     | arg_var EQUAL expr                  { return n :Assignment, val[0], val[2] }
    arg_var:           IDENTIFIER                          { return n :Variable, val[0] }

    method_call:            method_call_on_object
                          | method_call_on_self
    method_call_on_object:  expr DOT call_signature        { return n :MethodCall, val[0], val[2] }
    method_call_on_self:    call_signature                 { return n :MethodCall, scope_instance, val[0] }

    call_signature:         call_arguments
                          | call_simple_name
    call_simple_name:       CALL                           { return n :CallSignature, val[0] }
    call_argument:          SIGNATURE call_passed_arg      { return n :CallSignature, val[0], [val[1]] }
    call_passed_arg:        call_passed_simple
                          | call_passed_indented
    call_passed_simple:     expr
                          | expr NL
    call_passed_indented:   indented
                          | indented NL
    call_arguments:         call_argument                  { return val[0] }
                          | call_arguments call_argument   { return val[0].concat_signature val[1] }

    grouped_expr: OPAREN expr CPAREN            { return n :Expression, val[1] }

    variable:  IDENTIFIER                       { return allocate_local val[0] }

    binary_op: assignment
             | addition
             | subtraction
             | multiplication
             | division
             | exponentiation
             | modulo
             | equality

    assignment:     IDENTIFIER EQUAL expr { return allocate_local_assignment val[0], val[2] }
    addition:       expr PLUS expr        { return binary val[0], val[2], 'add:' }
    subtraction:    expr MINUS expr       { return binary val[0], val[2], 'subtract:' }
    multiplication: expr ASTERISK expr    { return binary val[0], val[2], 'multiplyBy:' }
    division:       expr FWD_SLASH expr   { return binary val[0], val[2], 'divideBy:' }
    exponentiation: expr EXPO expr        { return binary val[0], val[2], 'toThePowerOf:' }
    modulo:         expr PERCENT expr     { return binary val[0], val[2], 'moduloOf:' }
    equality:       expr EQUALITY expr    { return binary val[0], val[2], 'isEqualTo:' }

    literal:   integer
             | float
             | string
             | symbol
             | nil
             | true
             | false
             | self

    symbol:         SYMBOL                      { return n :Symbol,  val[0] }
    float:          FLOAT                       { return n :Float,   val[0] }
    integer:        INTEGER                     { return n :Integer, val[0] }
    string:         STRING                      { return n :String,  val[0] }
    nil:            NIL                         { return n :Nil }
    true:           TRUE                        { return n :True }
    false:          FALSE                       { return n :False }
    self:           SELF                        { return n :Self }

end

---- inner

attr_accessor :lexer, :state, :scopes

def initialize lexer
  @lexer  = lexer
  @state  = []
  @scopes = []
  push_scope
end

def ast
  @ast ||= do_parse
  @scopes.first
end

#def do_parse
#super
#rescue ParseError => e
#  raise SyntaxError, "#{e.message} on line #{@lexer.lineno}"
#end

#def on_error t, val, vstack
#  binding.pry
#end

def next_token
  nt = lexer.next_computed_token
  # just use a state stack for now, we'll have to do something
  # more sophisticated soon.
  if nt && nt.first == :state
    if nt.last
      state.push << nt.last
    else
      state.pop
    end
    next_token
  else
    nt
  end
end

def push_scope
  new_scope = Huia::AST::Scope.new scope
  new_scope.line = lexer.lineno
  scopes.push new_scope
  new_scope
end

def pop_scope
  scopes.pop
end

def scope
  scopes.last
end

def binary left, right, method
  node(:MethodCall, left, node(:CallSignature, method, [right]))
end

def node type, *args
  Huia::AST.const_get(type).new(*args).tap do |n|
    n.line = lexer.lineno
  end
end
alias n node

def allocate_local name
  node(:Variable, name).tap do |n|
    scope.allocate_local n
  end
end

def allocate_local_assignment name, value
  node(:Assignment, name, value).tap do |n|
    scope.allocate_local n
  end
end

def scope_instance
  node(:ScopeInstance, scope)
end

def constant name
  return scope_instance if name == 'self'
  node(:Constant, name)
end
