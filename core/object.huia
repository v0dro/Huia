# `Object.if:then:else:` & `Object#if:then:else:` **Private**
# ===========================================================
#
# Provide basic "if then else" control flow by using the builtin `if:then:`
# method provided by the VM.
#
# Arguments:
#   - `test`: the expression to test for truthiness.
#   - `positive`: the Closure or block argument to call if the test is truthy.
#   - `negative`: the Closure or block argument to call if the test is falsy.

ifThenElse = Closure.create: |test,positive,negative|
  result  = nil
  wasFalse = true

  if: test then: |_result|
    result = _result
    positive.callWithSelf: self andArgs: [result]
    wasFalse = false

  if: wasFalse then:
    negative.callWithSelf: self andArgs: [result]

definePrivateMethod: 'if:then:else:' as: ifThenElse

definePrivateInstanceMethod: 'if:then:else:' as: ifThenElse

# `Object.unless:then:` & `Object#unless:then:` **Private**
# =========================================================
#
# Provide basic "unless then" control flow by using the builtin `if:then:`
# method provided by the VM.
#
# Arguments:
#   - `test`: the expression to test for truthiness.
#   - `negative`: the Closure or block argument to call if the test is falsy.

unlessThen = Closure.create: |test,negative|
  if: (!test) then:
    negative.callWithSelf: self andArgs: [result]

definePrivateMethod: 'unless:then:' as: unlessThen

definePrivateInstanceMethod: 'unless:then:' as: unlessThen

# `Object#class` **Public**
# =========================
#
# Return the class that this object was cloned from.
defineInstanceMethod: 'class' as:
  get: 'class'

# `Object.respondsTo:` & `Object#respondsTo:` **Public**
# ======================================================
#
# Returns true of the receiver responds to the passed method signature.
#
# Arguments:
#   - `signature` (String): method signature.
respondsTo = Closure.create: |signature|
  hasMethod = Ruby.createFromObject: (get: 'methods')
  .send: 'keys'
  .send: 'member?' withArgs: [signature]

  hasMethod.truthy?

defineMethod: 'respondsTo:' as: respondsTo

defineInstanceMethod: 'respondsTo:' as: respondsTo

# `Object.unaryNot` & `Object#unaryNot` **Public**
# ================================================
#
# Returns false.
defineMethod: 'unaryNot' as:
  false

defineInstanceMethod: 'unaryNot' as:
  false

# `Object.truthy?` & `Object#truthy?` **Public**
# ==============================================
#
# Returns true.
def: 'truthy?' as:
  true

defineMethod: 'truthy?' as:
  true

# `Object.falsy?` & `Object#falsy?` **Public**
# ============================================
#
# Returns the unary not of `self.truthy?`
def: 'falsy?' as:
  !self.truthy?

defineMethod: 'falsy?' as:
  !self.truthy?

# `Object.isNotEqualTo:` & `Object#isNotEqualTo:` **Public**
# ==========================================================
#
# Returns the unary not of `self.isEqualTo: other`
isNotEqualTo = Closure.create: |other|
  !(self.isEqualTo: other)

defineMethod: 'isNotEqualTo:' as: isNotEqualTo

def: 'isNotEqualTo:' as: isNotEqualTo
