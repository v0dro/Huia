# These are the basic methods defined on Object.
# There are seven magically defined in the runtime:
#
#   - `get:` retrieves an instance variable.
#   - `set:to:` sets an instance variable to a value.
#   - `defineMethod:as:` defines a methods on the receiver.
#   - `definePrivateMethod:as` defines a a private method on the receiver.
#   - `defaultResponderFor:` finds the requested method and returns it.
#   - `sendMessage:withArgs:` calls `defaultResponderFor:` then executes the
#      closure in the receiver's scope (after a privacy check).
#   - `if:then:` executes the `then` if the `if` argument is truthy.
#
#   Note that you can override any of these methods in your subclass.

ifThenElse = Closure.create: |test,positive,negative|
  result  = nil
  wasFalse = true

  if: test then: |_result|
    result = _result
    positive.callWithSelf: self andArgs: [result]
    wasFalse = false

  if: wasFalse then:
    negative.callWithSelf: self andArgs: [result]

definePrivateMethod: 'if:then:else:' as: ifThenElse

definePrivateInstanceMethod: 'if:then:else:' as: ifThenElse

unlessThen = Closure.create: |test,positive|
  if: (!test) then:
    positive.callWithSelf: self andArgs: [result]

definePrivateMethod: 'unless:then:' as: unlessThen

definePrivateInstanceMethod: 'unless:then:' as: unlessThen

defineInstanceMethod: 'class' as:
  get: 'class'

respondsTo = Closure.create: |method|
  hasMethod = Ruby.createFromObject: (get: 'methods')
  .send: 'keys'
  .send: 'member?' withArgs: [method]

  hasMethod.truthy?

defineMethod: 'respondsTo:' as: respondsTo

defineInstanceMethod: 'respondsTo:' as: respondsTo

defineMethod: 'unaryNot' as:
  false

defineInstanceMethod: 'unaryNot' as:
  false

def: 'truthy?' as:
  true

defineMethod: 'truthy?' as:
  true

def: 'falsy?' as:
  !self.truthy?

defineMethod: 'falsy?' as:
  !self.truthy?

isNotEqualTo = Closure.create: |other|
  !(self.isEqualTo: other)

defineMethod: 'isNotEqualTo:' as: isNotEqualTo

def: 'isNotEqualTo:' as: isNotEqualTo
